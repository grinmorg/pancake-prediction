import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { ethers } from 'ethers';
import { TelegramService } from '../telegram-bot/telegram.service';
import { predictionAbi } from './pancake-prediction-abi';

const CONTRACT_ADDRESS = '0x18b2a687610328590bc8f2e5fedde3b582a49cda';

interface Round {
  epoch: number;
  startTimestamp: number;
  lockTimestamp: number;
  closeTimestamp: number;
  lockPrice: bigint;
  closePrice: bigint;
  totalAmount: bigint;
  bullAmount: bigint;
  bearAmount: bigint;
  oracleCalled: boolean;
  canBet: boolean;
}

interface BetStream {
  id: number;
  currentAmount: bigint;
  lossCount: number;
  lastEpoch: number | null;
  positionHistory: Array<'Bull' | 'Bear'>;
}

interface BetHistory {
  epoch: number;
  position: 'Bull' | 'Bear';
  amount: bigint;
  claimed: boolean;
  streamId: number;
}

@Injectable()
export class PredictionService implements OnModuleInit {
  private readonly LOSS_MULTIPLIER = 2n;
  private readonly logger = new Logger(PredictionService.name);
  private provider: ethers.JsonRpcProvider;
  private wallet: ethers.Wallet;
  private contract: ethers.Contract;
  private currentBetAmount: bigint;
  private baseBetAmount: bigint;
  private lastBetPosition: 'Bull' | 'Bear' | null = null;
  private lastBetEpoch: number | null = null;
  private betHistory: BetHistory[] = [];
  private readonly WIN_STREAK_TO_CLAIM = 3;
  private activeStreams: BetStream[] = [];
  private readonly MAX_STREAMS = 2;
  private lastUsedStreamIndex = 0;

  constructor(
    private readonly config: ConfigService,
    private readonly telegramService: TelegramService,
  ) {}

  async onModuleInit() {
    await this.initializeProvider();
    await this.initializeContract();

    // Initialize the bet streams
    this.activeStreams = Array.from({ length: this.MAX_STREAMS }, (_, i) => ({
      id: i + 1,
      currentAmount: this.baseBetAmount,
      lossCount: 0,
      lastEpoch: null,
      positionHistory: [],
    }));

    this.listenToEvents();
    this.startBettingStrategy();
  }

  private async initializeProvider() {
    try {
      const privateKey = this.config.get<string>('WALLET_PRIVATE_KEY');
      if (!privateKey?.startsWith('0x')) {
        throw new Error('Invalid private key format. Must start with 0x');
      }

      this.provider = new ethers.JsonRpcProvider(
        this.config.get('BSC_RPC_URL') || 'https://bsc-dataseed.binance.org/',
        {
          name: 'binance',
          chainId: 56,
        },
      );

      this.wallet = new ethers.Wallet(privateKey, this.provider);

      this.logger.log(`Connected to BSC network`);
      this.logger.log(`Operator address: ${this.wallet.address}`);
      this.logger.log(
        `Balance: ${ethers.formatEther(await this.provider.getBalance(this.wallet.address))} BNB`,
      );
    } catch (error) {
      this.logger.error('Provider initialization failed', error.stack);
      throw error;
    }
  }

  private async initializeContract() {
    this.contract = new ethers.Contract(
      CONTRACT_ADDRESS,
      predictionAbi,
      this.wallet,
    );

    this.baseBetAmount = await this.contract.minBetAmount();
    this.currentBetAmount = this.baseBetAmount;
    this.logger.log(
      `Min bet amount: ${ethers.formatEther(this.baseBetAmount)} BNB`,
    );
  }

  private listenToEvents() {
    this.contract.on('LockRound', async (epoch, price) => {
      const round = await this.getRoundData(epoch);

      // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–ø–ª–∞—Ç–∞—Ö
      const total = BigInt(round.totalAmount);

      const treasuryFee = (total * BigInt(300n)) / 10000n;
      const prizePool = total - treasuryFee;
      const bullPayout =
        round.bullAmount > 0n ? prizePool / BigInt(round.bullAmount) : 0n;
      const bearPayout =
        round.bearAmount > 0n ? prizePool / BigInt(round.bearAmount) : 0n;

      const message =
        `üîí Round #${epoch} locked at ${ethers.formatEther(price)}\n` +
        `üìä Total bets: ${ethers.formatEther(total)} BNB\n` +
        `üêÇ Bull: ${ethers.formatEther(round.bullAmount)} BNB | Payout: x${bullPayout}\n` +
        `üêª Bear: ${ethers.formatEther(round.bearAmount)} BNB | Payout: x${bearPayout}\n` +
        `üè¶ Treasury fee: ${ethers.formatEther(treasuryFee)} BNB`;

      this.telegramService.sendMessage(
        this.config.get('RECEIVER_TELEGRAM_ID'),
        message,
      );
    });

    this.contract.on('EndRound', async (epoch) => {
      const betsForRound = this.betHistory.filter(
        (b) => b.epoch === Number(epoch),
      );
      if (betsForRound.length > 0) {
        await this.handleRoundResult(Number(epoch));
        await this.checkAndClaimWinnings();
      }
    });

    this.provider.on('error', (error) => {
      this.logger.error('Provider error:', error);
      this.sendTelegramMessage(`‚ö†Ô∏è Provider error: ${error.message}`);
    });
  }

  private async handleRoundResult(epoch: number) {
    const round = await this.getRoundData(epoch);
    const betsForRound = this.betHistory.filter((b) => b.epoch === epoch);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç–∞–≤–∫–∏
    betsForRound.forEach((bet) => {
      const stream = this.activeStreams.find((s) => s.id === bet.streamId);
      if (!stream) return;

      const isWin = this.checkSingleBetResult(bet, round);
      const resultEmoji = isWin ? '‚úÖ' : '‚ùå';
      const resultText = isWin ? 'WON' : 'LOST';

      const message =
        `${resultEmoji} Stream #${stream.id} ${resultText} round #${epoch}\n` +
        `üí∞ Bet: ${ethers.formatEther(bet.amount)} BNB on ${bet.position}\n` +
        `üîí Lock: ${ethers.formatUnits(round.lockPrice, 8)}\n` +
        `üîì Close: ${ethers.formatUnits(round.closePrice, 8)}\n` +
        `üìâ Loss Streak: ${stream.lossCount}`;

      this.sendTelegramMessage(message);
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Ç–æ–∫–æ–≤
    betsForRound.forEach((bet) => {
      const stream = this.activeStreams.find((s) => s.id === bet.streamId);
      if (!stream) return;

      const isWin = this.checkSingleBetResult(bet, round);

      if (isWin) {
        stream.currentAmount = this.baseBetAmount;
        stream.lossCount = 0;
      } else {
        stream.currentAmount = stream.currentAmount * this.LOSS_MULTIPLIER;
        stream.lossCount++;
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –ø–æ–∑–∏—Ü–∏–π
      stream.positionHistory.push(bet.position);
      if (stream.positionHistory.length > 5) {
        stream.positionHistory.shift();
      }
    });

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å—Ç–∞–≤–∫–∏ –ø–æ—Ç–æ–∫–æ–≤
    const streamsInfo = this.activeStreams
      .map(
        (stream) =>
          `üìä Stream #${stream.id}: ${ethers.formatEther(stream.currentAmount)} BNB\n` +
          `üìâ Losses: ${stream.lossCount}`,
      )
      .join('\n\n');

    this.sendTelegramMessage(
      `üîÑ Updated streams after round #${epoch}:\n\n${streamsInfo}`,
    );

    await this.checkAndClaimWinnings();
  }

  private async checkAndClaimWinnings() {
    if (this.betHistory.length < this.WIN_STREAK_TO_CLAIM) return;

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 –Ω–µ –∑–∞–∫–ª–µ–π–º–ª–µ–Ω–Ω—ã–µ —Å—Ç–∞–≤–∫–∏
    const unclaimedBets = this.betHistory.filter((b) => !b.claimed);
    this.sendTelegramMessage(
      `‚è≥ Non-claimed rounds count: ${unclaimedBets.length}, waiting ${this.WIN_STREAK_TO_CLAIM} streak.`,
    );

    if (unclaimedBets.length < this.WIN_STREAK_TO_CLAIM) return;

    // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 —Å—Ç–∞–≤–∫–∏
    const lastThreeBets = unclaimedBets.slice(-this.WIN_STREAK_TO_CLAIM);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ 3 –≤—ã–∏–≥—Ä–∞–ª–∏
    const rounds = await Promise.all(
      lastThreeBets.map((bet) => this.getRoundData(bet.epoch)),
    );

    const allWon = lastThreeBets.every((bet, index) =>
      this.checkSingleBetResult(bet, rounds[index]),
    );

    if (allWon) {
      const epochsToClaim = lastThreeBets.map((bet) => bet.epoch);
      try {
        const tx = await this.contract.claim(epochsToClaim);
        await tx.wait();

        // –ü–æ–º–µ—á–∞–µ–º —Å—Ç–∞–≤–∫–∏ –∫–∞–∫ –∑–∞–∫–ª–µ–π–º–ª–µ–Ω–Ω—ã–µ
        lastThreeBets.forEach((bet) => {
          const betToUpdate = this.betHistory.find(
            (b) => b.epoch === bet.epoch && b.position === bet.position,
          );
          if (betToUpdate) betToUpdate.claimed = true;
        });

        this.sendTelegramMessage(
          `üèÜ Claimed rewards for rounds: ${epochsToClaim.join(', ')} | Tx: ${tx.hash}`,
        );
      } catch (error) {
        this.sendTelegramMessage(
          `‚ö†Ô∏è Failed to claim rewards: ${error.reason || error.message}`,
        );
      }
    }
  }

  private checkSingleBetResult(bet: BetHistory, round: Round): boolean {
    if (!round.oracleCalled) return false;

    return (
      (bet.position === 'Bull' && round.closePrice > round.lockPrice) ||
      (bet.position === 'Bear' && round.closePrice < round.lockPrice)
    );
  }

  private async startBettingStrategy() {
    setInterval(async () => {
      try {
        const currentEpoch = Number(await this.contract.currentEpoch());
        const nextEpoch = currentEpoch + 1;

        const currentRound = await this.getRoundData(currentEpoch);
        const nextRound = await this.getRoundData(nextEpoch);

        const bettingRound = this.isRoundBettable(nextRound)
          ? nextRound
          : currentRound;

        if (this.isBettable(bettingRound)) {
          // –í—ã–±–∏—Ä–∞–µ–º –ø–æ—Ç–æ–∫ –¥–ª—è —Å—Ç–∞–≤–∫–∏
          const stream = this.selectStreamForBet(bettingRound.epoch);
          if (stream) {
            await this.placeBet(bettingRound.epoch, stream);
          }
        }
      } catch (error) {
        this.sendTelegramMessage(
          `‚ùå Strategy error: ${error.reason || error.message}`,
        );
      }
    }, 1_000);
  }

  private selectStreamForBet(epoch: number): BetStream | null {
    const availableStreams = this.activeStreams.filter(
      (stream) =>
        stream.lastEpoch !== epoch &&
        !this.betHistory.some(
          (b) => b.epoch === epoch && b.streamId === stream.id,
        ),
    );

    if (availableStreams.length === 0) return null;

    // –í—ã–±–∏—Ä–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –ø–æ—Ç–æ–∫ –≤ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö
    const nextIndex =
      (this.activeStreams.findIndex((s) => s.id === availableStreams[0].id) +
        1) %
      this.activeStreams.length;
    return (
      availableStreams.find((s) => s.id === this.activeStreams[nextIndex].id) ||
      availableStreams[0]
    );
  }

  private isRoundBettable(round: Round): boolean {
    const now = Math.floor(Date.now() / 1000);
    return (
      round.startTimestamp <= now &&
      now < round.lockTimestamp &&
      !round.oracleCalled
    );
  }

  private isBettable(round: Round): boolean {
    const now = Math.floor(Date.now() / 1000);

    // –î–µ–ª–∞–µ–º —Å—Ç–∞–≤–∫—É –∑–∞ 15 —Å–µ–∫ –¥–æ –∫–æ–Ω—Ü–∞ —Ä–∞—É–Ω–¥–∞
    return (
      now >= round.lockTimestamp - 15 &&
      now < round.lockTimestamp &&
      this.isRoundBettable(round) &&
      !this.hasExistingBet(round.epoch)
    );
  }

  private hasExistingBet(epoch: number): boolean {
    return this.betHistory.some((b) => b.epoch === epoch && !b.claimed);
  }

  private async getRoundData(epoch: number): Promise<Round> {
    const roundData = await this.contract.rounds(epoch);
    const now = Math.floor(Date.now() / 1000);

    return {
      epoch: Number(roundData.epoch),
      startTimestamp: Number(roundData.startTimestamp),
      lockTimestamp: Number(roundData.lockTimestamp),
      closeTimestamp: Number(roundData.closeTimestamp),
      lockPrice: BigInt(roundData.lockPrice),
      closePrice: BigInt(roundData.closePrice),
      totalAmount: BigInt(roundData.totalAmount),
      bullAmount: BigInt(roundData.bullAmount),
      bearAmount: BigInt(roundData.bearAmount),
      oracleCalled: roundData.oracleCalled,
      canBet: now < Number(roundData.lockTimestamp) && !roundData.oracleCalled,
    };
  }

  private async placeBet(epoch: number, stream: BetStream) {
    const round = await this.getRoundData(epoch);
    const position = this.calculateBetPosition(round, stream);

    if (await this.hasSufficientBalance(stream.currentAmount)) {
      try {
        const method = position === 'Bull' ? 'betBull' : 'betBear';
        const tx = await this.contract[method](epoch, {
          value: stream.currentAmount,
        });

        this.betHistory.push({
          epoch,
          position,
          amount: stream.currentAmount,
          claimed: false,
          streamId: stream.id,
        });

        stream.lastEpoch = epoch;

        await tx.wait(1);
        this.sendTelegramMessage(
          `üé≤ Stream #${stream.id} bet ${ethers.formatEther(stream.currentAmount)} BNB on ${position} (#${epoch}) | Tx: ${tx.hash}`,
        );
      } catch (error) {
        this.sendTelegramMessage(
          `‚ö†Ô∏è Stream #${stream.id} bet error: ${error.reason || error.message}`,
        );
      }
    }
  }

  private calculateBetPosition(
    round: Round,
    stream: BetStream,
  ): 'Bull' | 'Bear' {
    // –ê–Ω–∞–ª–∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ–∑–∏—Ü–∏–π –¥–ª—è –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    const lastPosition =
      stream.positionHistory[stream.positionHistory.length - 1];
    const secondLast =
      stream.positionHistory[stream.positionHistory.length - 2];

    // –ï—Å–ª–∏ –¥–≤–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –ø—Ä–æ–∏–≥—Ä—ã—à–∞ –Ω–∞ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ - –º–µ–Ω—è–µ–º
    if (lastPosition && lastPosition === secondLast) {
      return lastPosition === 'Bull' ? 'Bear' : 'Bull';
    }

    // –ë–∞–∑–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
    const treasuryFee = (round.totalAmount * 300n) / 10000n;
    const prizePool = round.totalAmount - treasuryFee;

    const bullPayout =
      round.bullAmount > 0n ? prizePool / round.bullAmount : 0n;
    const bearPayout =
      round.bearAmount > 0n ? prizePool / round.bearAmount : 0n;

    return bullPayout > bearPayout ? 'Bull' : 'Bear';
  }

  private async hasSufficientBalance(betAmount: bigint): Promise<boolean> {
    const balance = await this.provider.getBalance(this.wallet.address);

    if (balance < betAmount) {
      this.sendTelegramMessage(
        `‚ö†Ô∏è Insufficient balance for bet: ${ethers.formatEther(betAmount)} BNB`,
      );
      return false;
    }
    return true;
  }

  private sendTelegramMessage(message: string) {
    this.telegramService.sendMessage(
      this.config.get('RECEIVER_TELEGRAM_ID'),
      message,
    );
  }
}
